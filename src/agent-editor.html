<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Uniicon AI - Agent Instructions Editor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
            background: #f8fafc;
            margin: 0;
            padding: 0;
            color: #333;
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            min-height: 100vh;
        }

        .header {
            background: #fff;
            border: 2px solid #333;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 10px;
            color: #333;
        }

        .header p {
            color: #666;
            font-size: 1.1rem;
        }

        .agents-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 25px;
            margin-bottom: 30px;
        }

        .agent-card {
            background: #fff;
            border: 2px solid #333;
            border-radius: 15px;
            padding: 25px;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .agent-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.15);
        }

        .agent-header {
            display: flex;
            align-items: center;
            margin-bottom: 20px;
        }

        .agent-icon {
            font-size: 2rem;
            margin-right: 15px;
        }

        .agent-title {
            font-size: 1.4rem;
            font-weight: 600;
            color: #333;
        }

        .agent-description {
            color: #666;
            margin-bottom: 20px;
            line-height: 1.6;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-label {
            display: block;
            font-weight: 600;
            margin-bottom: 8px;
            color: #333;
        }

        .form-input, .form-textarea {
            width: 100%;
            padding: 12px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.2s ease;
            font-family: inherit;
        }

        .form-input:focus, .form-textarea:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .form-textarea {
            min-height: 120px;
            resize: vertical;
        }

        .char-counter {
            font-size: 12px;
            color: #666;
            text-align: right;
            margin-top: 5px;
        }

        .char-counter.warning {
            color: #ed8936;
        }

        .char-counter.error {
            color: #e53e3e;
        }

        .validation-status {
            margin-top: 10px;
            padding: 10px;
            border-radius: 8px;
            font-size: 14px;
            display: none;
        }

        .validation-status.valid {
            background: #f0fff4;
            border: 1px solid #68d391;
            color: #2f855a;
        }

        .validation-status.invalid {
            background: #fed7d7;
            border: 1px solid #fc8181;
            color: #c53030;
        }

        .validation-status.validating {
            background: #ebf4ff;
            border: 1px solid #90cdf4;
            color: #3182ce;
        }

        .agent-status {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
        }

        .status-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .status-active {
            background-color: #48bb78;
        }

        .status-inactive {
            background-color: #ed8936;
        }

        .update-btn {
            background: #333;
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s ease, opacity 0.2s ease;
            width: 100%;
        }

        .update-btn:hover {
            background: #555;
        }

        .update-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .save-all-section {
            background: #fff;
            border: 2px solid #333;
            border-radius: 15px;
            padding: 25px;
            text-align: center;
        }

        .save-all-btn {
            background: #333;
            color: white;
            border: none;
            padding: 15px 40px;
            border-radius: 10px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s ease;
            margin-right: 15px;
        }

        .save-all-btn:hover {
            background: #555;
        }

        .reset-btn {
            background: #fff;
            color: #333;
            border: 2px solid #333;
            padding: 15px 40px;
            border-radius: 10px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }

        .reset-btn:hover {
            background: #f0f0f0;
        }

        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 20px;
            border-radius: 8px;
            color: white;
            font-weight: 600;
            z-index: 1000;
            transform: translateX(400px);
            transition: transform 0.3s ease;
        }

        .notification.show {
            transform: translateX(0);
        }

        .notification.success {
            background: linear-gradient(135deg, #48bb78, #38a169);
        }

        .notification.error {
            background: linear-gradient(135deg, #e53e3e, #c53030);
        }

        .loading {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-top: 2px solid white;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 8px;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        .back-link {
            display: inline-block;
            color: #333;
            text-decoration: none;
            font-weight: 600;
            margin-bottom: 20px;
            padding: 10px 20px;
            background: #fff;
            border: 2px solid #333;
            border-radius: 8px;
            transition: background-color 0.2s ease;
        }

        .back-link:hover {
            background: #f0f0f0;
        }

        @media (max-width: 768px) {
            .agents-grid {
                grid-template-columns: 1fr;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .save-all-btn, .reset-btn {
                display: block;
                margin: 10px auto;
                width: 100%;
            }
        }

        /* Styles for embedded mode in Adobe Add-on */
        @media (max-width: 450px) {
            .container {
                padding: 10px;
            }
            
            .header {
                padding: 15px;
                margin-bottom: 15px;
            }
            
            .header h1 {
                font-size: 1.5rem;
            }
            
            .header p {
                font-size: 0.9rem;
            }
            
            .agents-grid {
                gap: 15px;
                margin-bottom: 20px;
            }
            
            .agent-card {
                padding: 15px;
            }
            
            .agent-title {
                font-size: 1.2rem;
            }
            
            .form-textarea {
                min-height: 80px;
                font-size: 12px;
            }
            
            .save-all-section {
                padding: 15px;
            }
            
            .save-all-btn, .reset-btn {
                padding: 12px 25px;
                font-size: 14px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <a href="javascript:history.back()" class="back-link">‚Üê Back to Uniicon</a>
        
        <div class="header">
            <h1>ü§ñ AI Agent Instructions Editor</h1>
            <p>Customize the behavior and instructions for each AI agent in your pipeline</p>
        </div>

        <div class="agents-grid" id="agents-grid">
            <!-- Agent cards will be populated here -->
        </div>

        <div class="save-all-section">
            <button class="save-all-btn" onclick="saveAllAgents()">
                üíæ Save All Changes
            </button>
            <button class="reset-btn" onclick="resetAllAgents()">
                üîÑ Reset to Defaults
            </button>
            <br><br>
            <button class="save-all-btn" onclick="saveAndReturn()" style="background: #28a745; margin-right: 0;">
                ‚úÖ Done - Return to Generator
            </button>
        </div>
    </div>

    <script>
        let agentsData = {};
        let originalAgentsData = {};

        const agents = [
            {
                id: 'extract',
                name: 'Extract Agent',
                icon: 'üîç',
                description: 'Analyzes user input to extract key requirements, themes, and context for icon generation.',
                role: 'Input Analysis Specialist',
                defaultInstructions: `You are an expert icon requirements analyst. Your role is to carefully examine user requests for icon generation and extract actionable insights.

CORE RESPONSIBILITIES:
1. Analyze user input for core concepts and themes
2. Identify specific visual elements needed
3. Extract style preferences and artistic direction
4. Determine emotional tone and mood requirements
5. Note any technical specifications (size, format, style)

ANALYSIS FRAMEWORK:
- What is the main subject/concept?
- What visual elements are explicitly or implicitly needed?
- What style or artistic approach is suggested?
- What emotion or mood should the icon convey?
- Are there any specific requirements or constraints?

OUTPUT REQUIREMENTS:
Provide a structured analysis that clearly identifies:
- Primary concept
- Key visual elements
- Style direction
- Emotional tone
- Technical requirements

Be thorough but concise. Focus on actionable insights that will guide the generation process effectively.`
            },
            {
                id: 'interpret',
                name: 'Interpret Agent',
                icon: 'üëÅÔ∏è',
                description: 'Analyzes generated images to ensure they meet requirements and provides feedback for improvements.',
                role: 'Visual Quality Assessor',
                defaultInstructions: `You are a visual content analyst specializing in icon quality assessment. Your role is to analyze generated images and provide constructive feedback.

CORE RESPONSIBILITIES:
1. Evaluate visual accuracy against original requirements
2. Assess icon design principles compliance
3. Check professional quality standards
4. Verify clarity and recognizability
5. Provide improvement suggestions

EVALUATION CRITERIA:
- Visual accuracy to the request
- Icon design best practices (simplicity, clarity, scalability)
- Professional quality and finish
- Brand compatibility and versatility
- Clarity at different sizes

ANALYSIS PROCESS:
1. Compare generated icon with original prompt
2. Evaluate design quality and professionalism
3. Check for clarity and recognizability
4. Assess suitability for intended use
5. Identify areas for improvement

OUTPUT REQUIREMENTS:
Provide clear, actionable feedback including:
- Accuracy assessment
- Quality evaluation
- Specific improvement suggestions
- Overall success rating

Focus on elements relevant for professional icon use and Adobe Express integration.`
            },
            {
                id: 'planner',
                name: 'Planner Agent',
                icon: 'üó∫Ô∏è',
                description: 'Creates detailed generation plans and strategies based on extracted requirements.',
                role: 'Strategic Design Planner',
                defaultInstructions: `You are a strategic design planner specializing in icon creation blueprints. Your role is to create comprehensive generation plans that guide successful icon creation.

CORE RESPONSIBILITIES:
1. Develop visual composition strategies
2. Plan color palettes and style directions
3. Design element hierarchy and positioning
4. Establish technical specifications
5. Create quality enhancement guidelines

PLANNING FRAMEWORK:
- Visual composition and layout strategy
- Color scheme and style direction
- Key elements positioning and hierarchy
- Technical specifications for optimal results
- Quality enhancement and finishing touches

PLANNING PROCESS:
1. Analyze extracted requirements
2. Design optimal visual composition
3. Plan style and aesthetic approach
4. Define technical parameters
5. Establish quality benchmarks

OUTPUT REQUIREMENTS:
Create a detailed generation plan that includes:
- Composition strategy (layout, balance, focal points)
- Style direction (artistic approach, visual style)
- Color palette recommendations
- Element hierarchy and positioning
- Technical specifications (format, size, quality)
- Success criteria and quality guidelines

Ensure the plan is specific, actionable, and optimized for AI image generation while maintaining professional icon standards.`
            },
            {
                id: 'generate',
                name: 'Generate Agent',
                icon: 'üé®',
                description: 'Creates the actual icon images using advanced AI image generation models.',
                role: 'Creative Image Generator',
                defaultInstructions: `You are an AI image generation specialist focused on creating professional icons. Your role is to produce high-quality icons that meet exact specifications.

CORE RESPONSIBILITIES:
1. Generate professional icons from detailed plans
2. Maintain consistent style and quality
3. Optimize for icon use cases (clarity, scalability)
4. Ensure professional appearance and finish
5. Meet all technical requirements

GENERATION PRINCIPLES:
- Follow provided generation plan precisely
- Prioritize clarity and recognizability
- Maintain professional aesthetic standards
- Optimize for scalability and versatility
- Ensure clean, polished finish

QUALITY STANDARDS:
- High visual clarity and definition
- Professional color usage and contrast
- Clean lines and well-defined shapes
- Appropriate level of detail for icon use
- Consistent style throughout

OUTPUT REQUIREMENTS:
Create icons that:
- Match the specified requirements exactly
- Demonstrate professional quality and finish
- Work effectively at various sizes
- Maintain visual clarity and impact
- Integrate well with Adobe Express workflows

Focus on creating visually appealing, professional icons that serve their intended purpose effectively while maintaining the highest quality standards.`
            }
        ];

        async function loadAgentData() {
            try {
                // Show loading state
                document.getElementById('agents-grid').innerHTML = '<div style="text-align: center; color: white; font-size: 18px;">Loading agent configurations...</div>';
                
                // Get agent configurations from server
                const response = await fetch('/api/agents');
                const result = await response.json();
                
                if (!result.success) {
                    throw new Error(result.error || 'Failed to load agent configurations');
                }
                
                // Combine with agent metadata
                for (const agent of agents) {
                    const serverConfig = result.agents[agent.id];
                    agentsData[agent.id] = {
                        ...agent,
                        currentInstructions: agent.defaultInstructions,
                        agentId: serverConfig?.agentId || getAgentId(agent.id),
                        aliasId: serverConfig?.aliasId || getAgentAliasId(agent.id),
                        status: serverConfig?.status || 'inactive'
                    };
                }
                
                originalAgentsData = JSON.parse(JSON.stringify(agentsData));
                renderAgents();
                
            } catch (error) {
                console.error('Error loading agent data:', error);
                showNotification('Failed to load agent configurations: ' + error.message, 'error');
                
                // Fallback to default data
                for (const agent of agents) {
                    agentsData[agent.id] = {
                        ...agent,
                        currentInstructions: agent.defaultInstructions,
                        agentId: getAgentId(agent.id),
                        aliasId: getAgentAliasId(agent.id),
                        status: 'inactive'
                    };
                }
                originalAgentsData = JSON.parse(JSON.stringify(agentsData));
                renderAgents();
            }
        }

        function getAgentId(agentType) {
            const agentIds = {
                extract: 'AIN8HDRSBV',
                interpret: 'NMLHZIHGZR', 
                planner: 'BR6FLJOHTV',
                generate: 'amazon.titan-image-generator-v1'
            };
            return agentIds[agentType] || 'Not configured';
        }

        function getAgentAliasId(agentType) {
            const aliasIds = {
                extract: '6QBYKHARVB',
                interpret: '9Q6DSVPYBF',
                planner: 'ERJBOK40FB',
                generate: 'N/A'
            };
            return aliasIds[agentType] || 'TSTALIASID';
        }

        function renderAgents() {
            const grid = document.getElementById('agents-grid');
            grid.innerHTML = '';

            for (const agentId in agentsData) {
                const agent = agentsData[agentId];
                const card = document.createElement('div');
                card.className = 'agent-card';
                card.innerHTML = `
                    <div class="agent-header">
                        <div class="agent-icon">${agent.icon}</div>
                        <div class="agent-title">${agent.name}</div>
                    </div>
                    
                    <div class="agent-status">
                        <div class="status-indicator ${agent.status === 'active' ? 'status-active' : 'status-inactive'}"></div>
                        <span>${agent.status === 'active' ? 'Active' : 'Inactive'}</span>
                    </div>
                    
                    <div class="agent-description">${agent.description}</div>
                    
                    <div class="form-group">
                        <label class="form-label">Agent Role</label>
                        <input type="text" class="form-input" value="${agent.role}" readonly>
                    </div>
                    
                    <div class="form-group">
                        <label class="form-label">Agent ID</label>
                        <input type="text" class="form-input" value="${agent.agentId}" readonly>
                    </div>
                    
                    <div class="form-group">
                        <label class="form-label">Alias ID</label>
                        <input type="text" class="form-input" value="${agent.aliasId}" readonly>
                    </div>
                    
                    <div class="form-group">
                        <label class="form-label">Instructions</label>
                        <textarea 
                            class="form-textarea" 
                            id="instructions-${agentId}"
                            placeholder="Enter detailed instructions for this agent (minimum 100 characters)..."
                            oninput="handleInstructionsInput('${agentId}', this.value)"
                            onblur="validateInstructions('${agentId}')"
                        >${agent.currentInstructions}</textarea>
                        <div class="char-counter" id="counter-${agentId}">
                            ${agent.currentInstructions.length} / 4000 characters
                        </div>
                        <div class="validation-status" id="validation-${agentId}"></div>
                    </div>
                    
                    <button class="update-btn" id="update-${agentId}" onclick="updateAgent('${agentId}')" disabled>
                        Validate & Update Agent
                    </button>
                `;
                grid.appendChild(card);
                
                // Initialize character counter and button state
                updateCharCounter(agentId, agent.currentInstructions);
                handleInstructionsInput(agentId, agent.currentInstructions);
            }
        }

        function updateInstructions(agentId, instructions) {
            if (agentsData[agentId]) {
                agentsData[agentId].currentInstructions = instructions;
            }
        }

        function handleInstructionsInput(agentId, instructions) {
            updateInstructions(agentId, instructions);
            updateCharCounter(agentId, instructions);
            
            // Enable/disable update button based on length
            const updateBtn = document.getElementById(`update-${agentId}`);
            const minLength = 100;
            
            if (instructions.length >= minLength) {
                updateBtn.disabled = false;
                updateBtn.textContent = 'Validate & Update Agent';
            } else {
                updateBtn.disabled = true;
                updateBtn.textContent = `Need ${minLength - instructions.length} more characters`;
            }
        }

        function updateCharCounter(agentId, instructions) {
            const counter = document.getElementById(`counter-${agentId}`);
            const length = instructions.length;
            const maxLength = 4000;
            const minLength = 100;
            
            counter.textContent = `${length} / ${maxLength} characters`;
            
            // Update counter styling
            counter.className = 'char-counter';
            if (length < minLength) {
                counter.className += ' error';
            } else if (length > maxLength * 0.9) {
                counter.className += ' warning';
            }
        }

        async function validateInstructions(agentId) {
            const instructions = agentsData[agentId].currentInstructions;
            const agent = agentsData[agentId];
            const statusDiv = document.getElementById(`validation-${agentId}`);
            
            if (instructions.length < 100) {
                showValidationStatus(agentId, 'invalid', 'Instructions must be at least 100 characters long.');
                return false;
            }
            
            // Show validating state
            showValidationStatus(agentId, 'validating', 'Validating instructions with AI...');
            
            try {
                const response = await fetch('/api/validate-instructions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        instructions: instructions,
                        agentType: agentId,
                        agentRole: agent.role
                    })
                });
                
                const result = await response.json();
                
                if (!result.success) {
                    throw new Error(result.error || 'Validation failed');
                }
                
                const validation = result.validation;
                
                if (validation.valid) {
                    showValidationStatus(agentId, 'valid', 
                        validation.message || 'Instructions validated successfully!');
                    return true;
                } else {
                    let errorMsg = validation.error || 'Validation failed';
                    if (validation.details && validation.details.length > 0) {
                        errorMsg += ' Issues: ' + validation.details.join(', ');
                    }
                    showValidationStatus(agentId, 'invalid', errorMsg);
                    return false;
                }
                
            } catch (error) {
                console.error('Validation error:', error);
                showValidationStatus(agentId, 'invalid', 'Validation failed: ' + error.message);
                return false;
            }
        }

        function showValidationStatus(agentId, type, message) {
            const statusDiv = document.getElementById(`validation-${agentId}`);
            statusDiv.className = `validation-status ${type}`;
            statusDiv.textContent = message;
            statusDiv.style.display = 'block';
            
            // Auto-hide after 5 seconds for success messages
            if (type === 'valid') {
                setTimeout(() => {
                    statusDiv.style.display = 'none';
                }, 5000);
            }
        }

        async function updateAgent(agentId) {
            const btn = document.getElementById(`update-${agentId}`);
            const originalText = btn.textContent;
            
            try {
                btn.disabled = true;
                btn.innerHTML = '<div class="loading"></div>Validating...';
                
                // First validate the instructions
                const isValid = await validateInstructions(agentId);
                
                if (!isValid) {
                    btn.disabled = false;
                    btn.textContent = originalText;
                    return;
                }
                
                btn.innerHTML = '<div class="loading"></div>Updating...';
                
                const instructions = agentsData[agentId].currentInstructions;
                
                const response = await fetch(`/api/agents/${agentId}/instructions`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        instructions: instructions
                    })
                });
                
                const result = await response.json();
                
                if (!result.success) {
                    throw new Error(result.error || 'Failed to update agent');
                }
                
                showNotification(`${agentsData[agentId].name} updated successfully!`, 'success');
                showValidationStatus(agentId, 'valid', 'Agent updated and ready to use!');
                
            } catch (error) {
                console.error('Error updating agent:', error);
                showNotification(`Failed to update ${agentsData[agentId].name}: ` + error.message, 'error');
                showValidationStatus(agentId, 'invalid', 'Update failed: ' + error.message);
            } finally {
                btn.disabled = false;
                btn.textContent = originalText;
            }
        }

        async function saveAllAgents() {
            const btn = event.target;
            const originalText = btn.textContent;
            
            try {
                btn.disabled = true;
                btn.innerHTML = '<div class="loading"></div>Saving All...';
                
                // Update all agents one by one
                const updatePromises = [];
                for (const agentId in agentsData) {
                    const instructions = agentsData[agentId].currentInstructions;
                    updatePromises.push(
                        fetch(`/api/agents/${agentId}/instructions`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                instructions: instructions
                            })
                        })
                    );
                }
                
                const responses = await Promise.all(updatePromises);
                const results = await Promise.all(responses.map(r => r.json()));
                
                const failedUpdates = results.filter(r => !r.success);
                if (failedUpdates.length > 0) {
                    throw new Error(`Failed to update ${failedUpdates.length} agents`);
                }
                
                originalAgentsData = JSON.parse(JSON.stringify(agentsData));
                showNotification('All agent configurations saved successfully!', 'success');
                
            } catch (error) {
                console.error('Error saving agents:', error);
                showNotification('Failed to save agent configurations: ' + error.message, 'error');
            } finally {
                btn.disabled = false;
                btn.textContent = originalText;
            }
        }

        async function saveAndReturn() {
            const btn = event.target;
            const originalText = btn.textContent;
            
            try {
                btn.disabled = true;
                btn.innerHTML = '<div class="loading"></div>Finalizing...';
                
                // Validate all agents first
                let allValid = true;
                for (const agentId in agentsData) {
                    const isValid = await validateInstructions(agentId);
                    if (!isValid) {
                        allValid = false;
                        break;
                    }
                }
                
                if (!allValid) {
                    showNotification('Please fix validation errors before proceeding', 'error');
                    btn.disabled = false;
                    btn.textContent = originalText;
                    return;
                }
                
                // Save all agents
                await saveAllAgents();
                
                // Show success notification
                showNotification('All agents configured successfully! Redirecting...', 'success');
                
                // Wait a moment then redirect
                setTimeout(() => {
                    if (window.opener) {
                        // If opened as popup, close and refresh parent
                        window.opener.location.reload();
                        window.close();
                    } else {
                        // If opened as navigation, go back
                        window.history.back();
                    }
                }, 2000);
                
            } catch (error) {
                console.error('Error in saveAndReturn:', error);
                showNotification('Failed to save changes: ' + error.message, 'error');
                btn.disabled = false;
                btn.textContent = originalText;
            }
        }

        async function resetAllAgents() {
            if (!confirm('Are you sure you want to reset all agents to their default instructions? This cannot be undone.')) {
                return;
            }
            
            const btn = event.target;
            const originalText = btn.textContent;
            
            try {
                btn.disabled = true;
                btn.innerHTML = '<div class="loading"></div>Resetting...';
                
                // Reset to default instructions
                for (const agent of agents) {
                    agentsData[agent.id].currentInstructions = agent.defaultInstructions;
                }
                
                await new Promise(resolve => setTimeout(resolve, 1000));
                renderAgents();
                showNotification('All agents reset to default instructions', 'success');
                
            } catch (error) {
                console.error('Error resetting agents:', error);
                showNotification('Failed to reset agent configurations', 'error');
            } finally {
                btn.disabled = false;
                btn.textContent = originalText;
            }
        }

        function showNotification(message, type) {
            // Remove any existing notifications
            const existing = document.querySelector('.notification');
            if (existing) {
                existing.remove();
            }
            
            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.textContent = message;
            document.body.appendChild(notification);
            
            // Show notification
            setTimeout(() => notification.classList.add('show'), 100);
            
            // Hide notification after 4 seconds
            setTimeout(() => {
                notification.classList.remove('show');
                setTimeout(() => notification.remove(), 300);
            }, 4000);
        }

        // Initialize the page
        document.addEventListener('DOMContentLoaded', loadAgentData);
    </script>
</body>
</html>
